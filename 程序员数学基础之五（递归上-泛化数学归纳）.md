## 递归（上）泛化数学归纳
	   假设有四种面额的钱币，1元、2元、5元、和10元，你一共给我10元，那么你可以给我1张10元，
	或者10张1元，或者5张1元外加1张2元等等。考虑奖赏的金额和先后顺序呢，那么一共有多少种
	不同的奖赏方式？

　　**在限定综合的情况下，求所有可能的加和方式。**虽然问题不一样，但是求和的重复性操作仍然是一样的，所以可以使用迭代法。

　　**思考：**

* 使用迭代法中的术语，考虑k=1,2,3...n的情况。也就是n=1的时候，可以取四种面额中的任何一种那么当前的奖赏就是1元、2元、5元和10元。当n=2的时候，奖赏的综合就是有很多可能性了。如果第一次奖赏了1元，那么第二次有可能去1、2、5元三种面额（如果取10，总数超过了10元，因此不可能）。

　　所以、在第一次奖赏1元，第二次奖赏1元后，总和为2元；第一次奖赏1元。第二从奖赏2元后，总和为3元；第一次奖赏1元，第二次奖赏5元后，总和为6元。还要考虑第一次奖赏2元和5元等，如下图：
　　
　　![奖赏分析.jpg](https://s2.ax1x.com/2019/09/05/nnPCaF.jpg)

　　从上图可以看出来，用迭代发循环实现，需要经过太多步骤的迭代。

* 使用递归，每次嵌套调用都会让函数生成自己的局部变量，正好可以用来保存不同状态下的数值，为我们省去了大量中间变量的操作，极大地方便了设计和编程。用递归模拟数学归纳法非常直观，但是这里不是要计算一个最终的数值，而是要列举出所有的可能性。 所以需要用到需要将递归编程体现的数学归纳法思想泛化一下。
　　1.初始状态，也就是n=1的时候，命题是否成立。
　　2.如果n=k-1的时候，命题成立。那么只要证明n=k的时候，命题也成立。其中k为大于1的自然数。

　　将上述两点的顺序更换一下，再抽象化一下，递推关系如下：
　　1.假设n=k-1的时候为题已经解决（或者已经找到解）。那么只要求n=k的时候，问题是如何解决（或者解是多少）。
　　2.初始状态，就是n=1的时候会有多少奖赏。

	public static long[] rewards = {1, 2, 5, 10};

    public static void get(long totalReward, ArrayList<Long> result) {

        if (totalReward == 0) {
            //当 totalReward = 0 时，结束嵌套调用，输出解
            System.out.println(result);
            return;
        } else if (totalReward < 0){
            //当 totalReward < 0 时，证明它不是满足条件的解，不输出
            return;
        } else {
            for (int i = 0; i < rewards.length; i++) {

                ArrayList<Long> newResult = (ArrayList<Long>) result.clone();     //由于有 4 种情况，需要clone当前的解并传入被调用的函数
                newResult.add(rewards[i]);                                        // 记录当前的选择，解决一点问题
                get(totalReward - rewards[i],newResult);                //剩下的问题，留给嵌套调用去解决
            }
        }
    }

假如总金额为10,，有多少种解？
	public static void main(String[] args) {
        int totalReward = 10;
        Lesson5_1.get(totalReward,new ArrayList<Long>());
    }

运行结果：
	[1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
	[1, 1, 1, 1, 1, 1, 1, 1, 2]
	[1, 1, 1, 1, 1, 1, 1, 2, 1]
	[1, 1, 1, 1, 1, 1, 2, 1, 1]
	[1, 1, 1, 1, 1, 1, 2, 2]
	...
	[5, 2, 1, 2]
	[5, 2, 2, 1]
	[5, 5]
	[10]
　　以上结果中的每一行都是一种可能。
  
  
　　**注意：**
  
  
　　1、由于一共4种金额的纸币，所以无论n=1的时候还是mk的时候，我们只需要关心这4种金额对组合产生的影响，而中间状态和变量的记录和跟踪这些繁琐的事情都由函数的递归调用负责。
　　
　　2、此案例的限制条件不再是64个棋格，而是奖赏的总金额，因此判断嵌套调用是否结束的调价其实不是次数k,而是总金额。这个金额确保了递归不会陷入死循环。

　　3、此处从奖赏的中金额开始，每次嵌套调用的时候减去一张纸的金额，直到所剩的金额为0或者少于0，然后结束嵌套调用，开始返回结果值。也可以反向操作从金额0开始，每次嵌套调用时增加一张纸币的金额，直到累计金额达到或超过总金额。


#### 总结
　　**递归和循环其实都是迭代法的实现，而且在某些场合下，他们可以互相转化。** 但是，但是在某些应用场景，递归确实很难被取代，原因如下:

　　第一、递归的核心思想和数学归纳法类似，并更具有广泛性。两者之间类似之处为：**将当前的问题化解我两部分：一个当前所采取的步骤和另一个更简单的问题。**

　　**1、一个当前所采取的步骤。** 这种步骤可能是进行一次运算（例如没给棋格的麦粒数是前一格的两倍），或者做一个选择（例如不同面额的纸币），或者是不同类型操作的结合（例如此篇的纸币赏金）等。

　　**2、另一个更简单的问题。** 经过上述步骤之后，运算的结果里目标值更近（例如赏金总额），或者是完成了更多的选择（例如纸币的选择）。而“更简单的问题”，又可以嵌套调用进一步简化和求解，直至达到结束条件。

　　第二、递归会使用计算机的函数嵌套调用。而函数的调用本身，就可以报错很多中间状态和变量值，因此极大的方便了编程的处理。
