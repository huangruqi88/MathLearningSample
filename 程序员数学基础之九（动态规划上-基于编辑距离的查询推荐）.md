## 动态规划 上（基于编辑距离的查询推荐）

#### 定义
　　在寻找各种可能的局部解中，找出可能达到最优的局部解的过程。

　　动态规划需要通过子问题的最优解，推导出最终问题的最优解，因此这种方法特别注重子问题之间的转移关系。我们工厂把这些子问题之间的转移成为**动态转移**，并把用于刻画这些状态转移的表达方式成为
**状态转移方程**。所以找到合适的状态转移方程，是动态规划的关键。


##### 编辑距离

　　当在搜索引擎的搜索框中输入单词的时候，有没有发现，搜索引擎会返回一系列相关的关键词，方便你直接
点击。甚至，当你某个单词输入有误的时候，搜索引擎依旧会返回正确的搜索结果。

　　搜索下拉提示和关键词纠错，这两个功能其实就是**查询推荐**。查询推荐的黑心思想其实就是，对于用户
的输入，查找相似的关键词并进行返回。而测量拉丁文的文本相似度，最常用的指标是**编辑距离（Edit Distance）**。

　　**定义：由一个字符串转成另一个字符串所需的最少编辑操作次数。（这个概念是俄罗斯科学家莱文斯坦提
出来的，所以我们也把编辑距离称作莱文斯坦距离[Levenshtein distance]）。**编辑距离越小，说明这两个
字符越想死，可以互相作为查询推荐。***编辑操作***有三种：把一个字符替换成另一个字符；插入一个字符；
删除一个字符。

	比如，我们想把mouuse转换成mouse，有很多方法可以实现，但是很显
	然，直接删除一个“u”是最简单的，所以这两者的编辑距离就是1。

##### 状态转移

	对于mouse和mouuse的例子，我们肉眼很快就能观察出来，编辑距离是1。
	但是对于我们现实的场景中，常常不会这么简单。如果给定任意两个非常
	复杂的字符串，如何高效的计算出他们之间的距离呢？

　　***排列思想***进行编辑操作。比如，把一个字符替换成另一个字符，我们可以想成吧A中的一个字符替换
成B中的一个字符。假设B中有m个不同的字符，那么替换的时候就有m种可能性。对于插入一个字符，我们可以想
长在A中插入来自B的一个字符，同样假设B中有m个不同的字符，那么也有m种可能性。至于删除一个字符，我们
可以项城在A中删除任何一个字符，假设A有n个不同的字符，那么有n种可能性。

　　可是，等到实现的时候，你会发现实际情况比想象中复杂得多。

　　首先，计算量非常大，我们假设字符串A的长度是n，而B字符串中不同的字符数量是m，那么A所有可能
的排列大致在 m^n 这个数量级，这会导致非常久的处理时间，对于查询推荐等实时性的服务而言，服务器的响应
时间太长。

　　其次，如果需要在字符串A中加字符，那么加几个？加在哪？同样，删除字符也是。因此，可能排列远不止m^n。

　　回到问题本身，其实编辑距离只需要求最先的操作次数，并不要求列出所有的可能。而且排列过程非常容易出错，
还会浪费大量的计算资源。所以排列方法不可行。

　　在此处我们并不需要排列出所有可能性，而是只关心最优解，也就是最短距离。那么，需要每次都选择出一个到目
前为止的最优解，并且只保留这种最优解。这样我们还是使用迭代或者递归编程来实现，效率上可以提升很多。

　　**1、最简单的情况：**假设字符串A和B都是空字符，那么很明显这个时候编辑距离就是0。如果A增加一个
字符a1，B保持不动，编辑距离就增加1。同样，如果B增加一个字符b1，A保持不动，编辑距离增加1。但是，如果A和B有
一个字符，那么问题就有点复杂了，我们可以分为下面几种情况。

　　**2、插入字符：**A字符串是a1的时候，B空串增加一个字符为b1；或者B字符串为b1的时候，A字符串增加一个
字符a1。很明显，这种情况下编辑距离都要增加1。

　　**3、替换字符：**当A和B都是空串的时候，同时增加一个字符。如果要加入的字符a1和b1不相等，表示A和B之间转化
的时候需要替换字符，那么编辑距离就是加1；如果a1和b1相等，无需替换，那么编辑距离不变。

　　最后，我们取上述三种情况中编辑距离的最小值最为当前的编辑距离。因为编辑距离随着字符串的增长，是单调递增的。
所以要求最终的最小值，必须要保证对于每个子串都取得了最小值。使用迭代的方式，一步步推导下去，直到两个字符串结束比较。


![MXbGng.md.png](https://s2.ax1x.com/2019/11/25/MXbGng.md.png)

　　上图中的不同状态之间的转移，就是**状态转移**。其中红色部分表示字符串演变（或者说状态转移）的方式以及相应的编辑距离计算。


　　编辑距离具有对称性，也就是说字符串A到B的编辑距离，和从字符串B到A的编辑距离，两者一定是相等的。


　　把刚才那个状态转移表，的行和列互换一下。从理论上上其实是由编辑距离的三种操作决定的。比如，从字符串A演变到B的每
一种操作，都可以转换为从字符串B演变到A的某一种操作。


　　![MjC7bq.md.jpg](https://s2.ax1x.com/2019/11/25/MjC7bq.md.jpg)

　　所以说，从字符串A演变到B的每一种变化方式，都可以找到对象的从字符串B演变到A的某种方式，；两者操作次数一样。自然，代表最小操作次数的编辑距离也就一样。


##### 总结

　　求任意连个字符串之间的编辑距离一般用于查询推荐。使用中一般采用化繁为简的思路，把编辑距离的计算拆分为3种情况，
并建立了子串之间的联系。

　　动态规划虽然也采用了把万体逐步简化的思想，但是它基于递归的归并排序、排列等解法有所不同。能够使用动态规划解决问题，通常只关心一个最优解，而这个最优解是单调改变的，例如最大值、最小值等等。因此，动态规划中的每种状态，通常只保留一个当前的最优解，这也是动态规划效率比较高的原因。























































