## 组合（计算机安排世界杯赛程）

　　世界杯组委会怎么安排比赛日程让全部的32支入围球队和其他球队进行一次主客场的比赛。以排列的思想实现如下：


　　***分析：***自己不可能和自己比赛，因此在这种不可重复的排列中，主场球队有32中选择，而客场球队有31种选择。那么一共要进行32*31=992场。一天看2场，也要一年多才能看完，场次太多不符合实际情况。

　　如果取消主客场制，让任意两个球队之间只要踢1场，结果就有原来两队之间的比赛由两场降为1场，所以比赛场次为992/2=496。比赛场次还是很多

　　所以世界杯赛制要将所有的32支队伍分成8个小组先进行小组赛的原因，一旦分成小组。每个小组的赛事就是（4*3）/2 = 6场。所有小组赛就是6*8=48场。

　　再加上16强阶段开始采取淘汰制，两两淘汰，所以需要8+4+2+2=16场淘汰赛（最后一次加2是因为还有3、4名的决赛），那么整个世界杯决赛阶段就是48+16=64场比赛。

#####概念
　　组合是指，从n个不同元素中取出m（1≤m≤n）个不同的元素。
	例如：以世界杯足球赛为例，从32支球队里找出任意2支球队进行比赛，就是从32个元素中取出2个元素的组合。如果田忌赛马的规则改一下，改为从10匹里挑出3匹比赛，但是不关心3匹马的出战顺序，那么就是一个组合的问题。

　　***组合和排列区别：***两者类似但是有有所不同，组合是不考虑每个元素出现的顺序。

　　**全组合（All Combination）：**对于所有m取值的组合之全集合。比如，对于集合{1，2，3}而言。全组合就是{空集，{1}，{2}，{3}，{1，2}，{1，3}，{2，3}，{1，2，3}，}。

　　如果我们安排足球比赛是，不考虑主客场，也就是不考虑这两只球队的顺序，两队只要踢一次就行了，那么从n个元素取出m个的组合，有多少种可能？

　　我们假设某种运动需要3支球队一起比赛，那么32支球队就有32*31*30种排列，如果三支球队在一起只要比一场，那么我们要抹除多余的比赛。三支球队按照任意顺序的比赛由3*2*1=6场，所以从32支队伍里取出3支队伍的组合就是(32*31*30) / (3*2*1).基于此，可以扩展成以下两种情况。

+ n个元素里面取出m个元素的组合，可能性数量就是n个里面取出m个的排列数量，除以m个全排列的数量，也就是(n!/(n-m)! / m!)。
+ 对于全组合而言，可能性为2^n 种。


####实现

　　全组合就是将所有元素列出来，没有太大意义。以下为例，如何使用递归从３个元素中选取２个元素的组合。

　　我们假设有3个队伍，t1,t2和t3。我还是把递归的选择画成图。从图中可以看出，对于组合而言，由于{t1,t2}已经出现了，因此就无需{t1,t2}。同理出现{t1,t3}，就无需{t3,t1}等等。对于重复的，用叉划掉了。最终只有3种组合。


![MaiVIO.png](https://s2.ax1x.com/2019/11/15/MaiVIO.png)


	1.先实现排列的代码，输出所有的排列。例如{t1,t2},{t2,t1}
	2.针对每种排列，对其中的元素按照一定的规则排序。那么上述两种排列经过排序后，就是{t1,t2},{t1,t2}
	3.对排序后的排列，去掉重复的那些。上述两种排列最终只保留一个{t1,t2}

　　这样做的效率太低，很多排列生成之后，最终还是要被当做重复的结果去掉。更好的做法如图中我们可以看出被划掉的那些，都是那些出现顺序和原有顺序颠倒的元素。

	例如，在原有集合中，t1在t2的前面，所以我们划掉了{t2,t1}的组合。因为，t1出现在t2之前，t1的组合中
	一定已经包含了t2，所有t2的组合就无需再考虑t1了。因此，我们只需要在原有的排列代码中，稍作修改，每次传入
	嵌套函数的声誉元素，不再是所有未选择元素，而是出现在当前被选元素之后的那些。具体代码是这样的：

	/**
     * @param teams  目前还有多少队伍没有参与组合
     * @param result 保存当前已有的组合队伍
     * @param m
     * @Description 使用函数的递归（嵌套）调用，找出所有可能队伍的组合
     */
    public static void combine(ArrayList<String> teams, ArrayList<String> result, int m) {
        // 挑选完了m个元素，输出结果
        if (result.size() == m) {
            System.out.println(result);
            return;
        }

        for (int i = 0; i < teams.size(); i++) {
            //从剩下的队伍中，选择一队，加入结果
            ArrayList<String> newResult = (ArrayList<String>) result.clone();
            newResult.add(teams.get(i));

            //只考虑当前选择之后的队伍
            ArrayList<String> restTeams = new ArrayList<>(teams.subList(i + 1, teams.size()));
            combine(restTeams, newResult, m);
        }
    }


    public static void main(String[] args) {
        ArrayList<String> teams = new ArrayList<>(Arrays.asList("t1","t2","t3"));
        Lesson8_1.combine(teams,new ArrayList<String>(),2);
    }

####应用

　　大型比赛中赛程的自动安排、多维度的数据分析以及自然语言处理的优化等等。
　　
　　
	比如：需要经每篇很长的文章，分割成一个个的单词，然后对每个单词进行索引，便于日后的查询。但是很多时候，光有单个的单词是不够的，还要考虑多个单词所组成的词组。例如，"red bluetooth mouse"这样的词组。处理单词最常见的一种方式是**多元文法**。

　　***多元文法：其实就是把临近的几个单词合并起来，组合一个新的词组。***比如我可以吧"red" 和"buletooth" 合并为"red bluetooth"，还可以把"bluetooth"和"bluetooth mouse"。

	设计多元文法只是为了方便计算机的处理，而不考虑组合后的词组是不是有正确的语法和语义。例如"red bluetooth"，从人类的角度来看，这个词就很奇怪。但是他还会成成很多合理的词组，例如"bluetooth mouse"。所以，如果不进行任何深入的语法分析，我们其实没办法区分哪些多元词组是有意义的，哪些是没有意义的，因此最简单的做法就是保留所有词组。

	普通的多元化文法本身存在一个问题，定死了每个元组内单词出现的顺序。例如中可能出现的是"red bluetooth mouse"。可是用户在查询的时候可能输入的是"bluetooth mouse red"。这么输入肯定不符合语法，但实际上互联网上的用户经常会这么干。

	那就是我们只保留原文的"red bluetooth mouse"，就无法将其和用户输入的"bluetooth red mouse"匹配了。所以，如果我们并不要求查询词组中单词所出现的顺序和原文一致。

	于是可以把每个二元或三元组进行全排列，得到所有的可能。但是这样的话，二元组的数量就会增加1被，三元组的数量就会增加5倍，一篇文章的数据保存量就会增加3倍左右，我也试过对用户查询做全排列，把原有的二元组查询变为2个不同的二元组查询，把原有的三元组查询变为6个不同的三元查询，但是事实是，这样会增加实时插损的耗时。

	于是就是用到了组合。多个单词的出现，并不关心他们的顺序，（也就是不关心排列），而只关心他们的组合。因为无需关心顺序，就意味着我可以对多元组内的单词进行某种形式的标准化。即使原来的单词出现顺序有所不同，经过这个标准化过程之后，都会变成唯一的顺序。

	例如，"red bluetooth mouse"这是哪个词排序后就是"bluetooth,mouse,red"，而"bluetooth red mouse"排序后也是"bluetooth,mouse,red"，自然两者就能匹配上了。我需要做的事情就是保存文章多元组和处理用户查询这两个阶段分别进行这种排序。这样既可以较少保存的数据量，同事可以较少查询的耗时。这个问题就解决了。

　　
　　组合思想在多维度数据分析中的应用。

	比如，需要设计一个连锁店的销售业绩报表。这挣报表有若干个属性，包括分店名称、所在城市、销售品类等等。那么醉基本的总结数据包括每个分店的销售额、每个城市的销售额、每个品类的销售额。除了这些最基本的数据，还可以利用组合的思想，生成更多的筛选条件。

#### 总结

　　***总结和排列相同点***：都是从n个元素中取出若干个元素。

　　***总结和排列不同点***排列考虑了取出元素他们之间的顺序，而组合无需考虑这种顺序。

　　所以组合适合找到多个元素之间的联系而并不在意他们之间的先后顺序，例如多元文法中的多元组。

　　具体到编程，组合和排列两者的实现非常类似。区别在于，组合并不考虑挑选出来的元素之间，是如何排序的。所以在递归的时候，传入下一个嵌套调用函数的剩余元素，只需要包含当前被选元素之后的那些，以避免重复的组合。